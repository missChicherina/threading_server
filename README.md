# threading_server

## Задания для выполнения:
1. Создать простой эхо-сервер и клиент для него.
2. Модифицировать код сервера таким образом, чтобы при подключении нового клиента создавался новый поток и вся работа с клиентом выполнялась в нем.
3. Проверить возможность подключения нескольких клиентов к этому серверу одновременно.

## Задания для самостоятельного выполнения
2. Модифицировать простой эхо-сервер таким образом, чтобы при подключении клиента создавался новый поток, в котором происходило взаимодействие с ним.
3. Реализовать простой чат сервер на базе сервера аутентификации. Сервер должен обеспечивать подключение многих пользователей одновременно, отслеживание имен пользователей, поддерживать историю сообщений и пересылку сообщений от каждого пользователя всем остальным.
4. Реализовать сервер с управляющим потоком. При создании сервера прослушивание портов происходит в отдельном потоке, а главный поток программы в это время способен принимать команды от пользователя. Необходимо реализовать следующие команды:
    * Отключение сервера (завершение программы);
    * Пауза (остановка прослушивание порта);
    * Показ логов;
    * Очистка логов;
    * Очистка файла идентификации.
  
## Контрольные вопросы на «Создание простого многопоточного сервера»

Почему однопоточное приложение не может решить задачу одновременного подключения?
> Ответ: ввиду того, что однопоточное приложение будет ждать ответа только одного из пользователей, и в процессе ожидания будут игнорироваться сообщения от других пользователей. Приложение просто не в состоянии одновременно обработать несколько пользовательских запросов

Чем поток отличается от процесса?
> Ответ: если рассматривать с точки зрения аппаратной части, то процесс будет выполняться на каком-то отдельном процессоре, а поток будет выполняться в каком-то отдельном процессе, если с точки зрения доступа к ресурсам (как апаратным, так и информационным), то процесс — это отдельный экземпляр программы, выполняемый в отдельном адресном пространстве один процесс не может получить доступ к переменным и структурам данных другого, поток же выполняется в процессе и (в случае изменения данных) в отдельном потоке все изменённые данные будут доступны другим потокам

Как создать новый поток?
> Ответ: надо выделить определённый участок кода при помощи функции, после чего создать отдельный поток и запустить в нём функцию, и применить библиотеку threading (как вариант на Python)

Как выделить участок кода так, чтобы он выполнялся в другом потоке?
> Ответ: выделить код как функцию и из выполняемого потока запустить новый для этой функции пример кода: new_thread = threading.Thread(target=function, name='name_new_thread')

В чём проблема потокобезопасности?
> Ответ: проблема в сложности предсказания момента переключения процесса между выполнением разных потоков, и ввиду чего может возникнуть проблема с одновременными попытками подключения разных потоков к одному и тому же месту (допустим, к терминалу), что может привести к наложению одного потока на другой. Например, первый поток выводит в терминал строчку 'Привет', а второй 'Как дела?', в случае, если произойдёт непредвиденное переключение с первого потока на второй и обратно, то в терминал будет выведено 'ПрКак дела?вет', ввиду чего произойдёт потеря данных

Какие методы обеспечения потокобезопасности существуют?
> Ответ: блокировка потока, которая не позволит подключиться потокам к одному и тому же терминалу, как в примере выше
